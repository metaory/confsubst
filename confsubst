#!/bin/bash

# #### ############ ########################################
# #### INFO: [VARS] ########################################
# #### ############
declare -a FILES
SCRIPT="${0##*/}"
ENVFILE='.env'
VERSION="0.0.1"
VERBOSE=0
LOGFILE=/tmp/mxsh.log
OUTPUT=/tmp/mxc
CMD_SYNTAX='confsubst [-elVvh] [-o DIR] [--] [-]|DIR|FILE...'

# #### ################### #################################
# #### INFO: [CONFIG_MAPS] #################################
# #### ###################
declare -A COL_MAP=( [0]=6 [1]=2 [2]=4 [3]=3 [4]=1 )
declare -A LBL_MAP=( [0]=TRACE [1]=OK [2]=INFO [3]=WARN [4]=ERROR )

# #### ############## ######################################
# #### INFO: [PRINTS] ######################################
# #### ##############
function _CC { tput setaf "${1}"; shift; printf '%s' "${*}"; tput sgr0; }
function _CO { _CC 2 "$1"; [[ -n "$2" ]] && printf ', ' && tput setaf 2 && _CC 2 "$2"; }

# ----------------------------------------------------------

function log {
  (( "$VERBOSE" )) && printf -v VRB '[%s:%s:%03d]' "${FUNCNAME[1]}" "${SCRIPT}" "${BASH_LINENO[0]}"
  printf '%s%s %s\n' "$(_CC "${COL_MAP[${1}]}" "[${LBL_MAP[${1}]:-N}]")" "${VRB:-}" "${*:2}" | \
    tee "$LOGFILE"
  (( "$1" >= 4 )) && exit "$1"
}

# ----------------------------------------------------------

function version_exit { echo "$(_CC 2 "${SCRIPT}") ${VERSION}" ; exit; }

# ----------------------------------------------------------

function badarg_exit {
  _CC 2 ': confsubst expects'
  _CC 3 $' [-]|DIR|FILE...\n\n'
  _CC 4  $'\n$ confsubst --help\n\n'
  _CC 2 "\$ ${CMD_SYNTAX}"
  exit
}

# ----------------------------------------------------------

function help_exit {
  cat << EOM
$(version_exit)
(C) 2024 Yan<metaory@gmail.com

confsubst - templating and variable interpolation CLI utility

$(_CC 3 USAGE:)
=====
$(_CC 1 "$CMD_SYNTAX")
  Substitute placeholders in file(s)

  $(_CC 4 'With no DIR|FILE..., or when FILE is [-], read STDIN')

$(_CC 3 OPTIONS)
=======
  $(_CO -e '--env <FILE>')   environment overrides
  $(_CO -o '--output <DIR>') output path
  $(_CO -l '--log <FILE>')   verbose log file
  $(_CO -V --verbose)      be more verbose
  $(_CO -h --help)         display this help and exit
  $(_CO -v --version)      display version and exit
EOM
  # $(_CO -f --force)           replace existing destination files
  # $(_CO -I --ignore-modeline) ignore any modeline
exit
}

# #### ############# #######################################
# #### INFO: [PARSE] #######################################
# #### #############
declare -A MOD_OPT

function set_mode_data {
  MOD_OPT=()
  while read -r L; do
    ! [[ $L =~ .*mx([c])?: ]] && continue
    while [[ $L =~ ([a-z]+)=([a-z0-9\/\-]+) ]]; do
      MOD_OPT["${BASH_REMATCH[1]}"]="${BASH_REMATCH[2]}"
      L=${L/"${BASH_REMATCH[0]}"/}
    done
  done <"$1"
}

# #### ########################## ##########################
# #### INFO: [REQUIREMENT CHECKS] ##########################
# #### ##########################
command -v envsubst &> /dev/null || log 11 'gnu envsubst command not found (provided by gnu gettext)'
command -v printenv &> /dev/null || log 11 'gnu printenv command not found (provided by gnu coreutils)'

# #### ################## ##################################
# #### INFO: [READ.STDIN] #######################################
# #### ##################
function readstdin { [ ! -t 0 ] && while read -r x ; do FILES+=( "$x" ) ; done; }

# #### ################# ###################################
# #### INFO: [READ.ARGS] ########################################
# #### #################
function readarg {
  while [[ "$1" =~ ^- && ! "$1" == "--" ]]; do case $1 in
    -e | --env     ) ENVFILE="$2"; shift ;;
    -o | --output  ) OUTPUT="$2";  shift ;;
    -l | --log     ) LOGFILE="$2"; shift ;;
    -V | --verbose ) VERBOSE=1    ;;
    -v | --version ) version_exit ;;
    -h | --help    ) help_exit    ;;
    --             ) break        ;;
    -              ) readstdin    ;;
    *              ) badarg_exit  ;;
  esac; shift; done

  for input in "${@}"; do
    [[ -f "$input" ]] && FILES+=( "$input" )
    [[ -d "$input" ]] && mapfile -t tmp < <(find "$input" -type f) || tmp=( )
    FILES+=("${tmp[@]}")
  done
}

# shellcheck source=/dev/null
function readenv { [[ -f $ENVFILE ]] && source "$ENVFILE"; }

# #### ############### #####################################
# #### INFO: [PROCESS] #####################################
# #### ###############
function process {
  ! (( "${#FILES[@]}" )) && badarg_exit

  mkdir "$OUTPUT" &> /dev/null

  for F in "${FILES[@]}"; do
    local T="${OUTPUT}/${F#*/}"
    set_mode_data "$F"

    log 2 "TP FILE" "$F"
    log 2 "MOD_OPT" "$(declare -p MOD_OPT)"

    envsubst < "${F}" | tee \
      "${T}" \
      "${MOD_OPT[path]:-/dev/null}" &> /dev/null

    log 1 "Created" "$T"
    log 1 "Updated" "$F"
    echo
  done
}

# #### ############ ########################################
# #### INFO: [MAIN] ########################################
# #### ############
function main {
  readarg "$@"
  readstdin
  readenv
  process
}

main "$@"
